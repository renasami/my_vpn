// Package system provides system-level integration for macOS firewall management.
// It handles pfctl (Packet Filter) configuration for WireGuard VPN traffic routing,
// NAT rules, and firewall management specific to macOS environments.
package system

import (
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// PfctlManager manages macOS pfctl firewall configuration for VPN operations.
// It provides methods for generating, applying, and managing pfctl rules
// that enable proper VPN traffic routing and network address translation.
type PfctlManager struct {
	configPath    string // Path to the main pfctl configuration file
	vpnConfigPath string // Path to the VPN-specific pfctl configuration file
}

// VPNConfig represents the network configuration parameters for pfctl rule generation.
// It contains the essential network information needed to create appropriate
// firewall rules for VPN traffic routing and NAT operations.
type VPNConfig struct {
	Interface         string `json:"interface"`           // WireGuard interface name (e.g., "wg0")
	VPNNetwork        string `json:"vpn_network"`         // VPN network CIDR (e.g., "10.0.0.0/24")
	ExternalInterface string `json:"external_interface"`  // External network interface (e.g., "en0")
	ListenPort        int    `json:"listen_port,omitempty"` // WireGuard listen port (optional)
	AllowedPorts      []int  `json:"allowed_ports,omitempty"` // Additional allowed ports (optional)
}

// PfctlStatus represents the current status of the pfctl firewall system.
// It provides information about the firewall state and rule configuration.
type PfctlStatus struct {
	State     string    `json:"state"`      // Firewall state: "enabled" or "disabled"
	RuleCount int       `json:"rule_count"` // Number of active firewall rules
	LastCheck time.Time `json:"last_check"` // Timestamp of the last status check
}

type PfctlRule struct {
	ID     int    `json:"id"`
	Action string `json:"action"`
	Rule   string `json:"rule"`
}

// NewPfctlManager creates a new pfctl manager with default configuration
func NewPfctlManager() *PfctlManager {
	return &PfctlManager{
		configPath:    "/etc/pf.conf",
		vpnConfigPath: "/tmp/pf_vpn.conf",
	}
}

// NewPfctlManagerWithConfig creates a new pfctl manager with custom configuration
func NewPfctlManagerWithConfig(configPath, vpnConfigPath string) *PfctlManager {
	return &PfctlManager{
		configPath:    configPath,
		vpnConfigPath: vpnConfigPath,
	}
}

// GenerateConfig generates pfctl configuration for VPN
func (pm *PfctlManager) GenerateConfig(config *VPNConfig) string {
	var pfConfig strings.Builder
	
	pfConfig.WriteString("# WireGuard VPN NAT Rules\n")
	pfConfig.WriteString("# Generated by VPN Server\n\n")
	
	// NAT rules
	pfConfig.WriteString(fmt.Sprintf("nat on %s from %s to any -> (%s)\n",
		config.ExternalInterface, config.VPNNetwork, config.ExternalInterface))
	
	// Basic rules
	pfConfig.WriteString("\n# Basic VPN rules\n")
	pfConfig.WriteString(fmt.Sprintf("pass in on %s\n", config.Interface))
	pfConfig.WriteString(fmt.Sprintf("pass out on %s\n", config.ExternalInterface))
	
	// WireGuard listen port
	if config.ListenPort > 0 {
		pfConfig.WriteString(fmt.Sprintf("pass in on %s proto udp to port %d\n",
			config.ExternalInterface, config.ListenPort))
	}
	
	// Allowed ports for VPN clients
	if len(config.AllowedPorts) > 0 {
		portList := make([]string, len(config.AllowedPorts))
		for i, port := range config.AllowedPorts {
			portList[i] = strconv.Itoa(port)
		}
		pfConfig.WriteString(fmt.Sprintf("pass out proto tcp to port { %s }\n",
			strings.Join(portList, " ")))
	}
	
	// Block all other traffic from VPN network to prevent leaks
	pfConfig.WriteString(fmt.Sprintf("\n# Security rules\nblock out from %s to any\n", config.VPNNetwork))
	pfConfig.WriteString(fmt.Sprintf("pass out from %s to %s\n", config.VPNNetwork, config.VPNNetwork))
	
	return pfConfig.String()
}

// WriteConfig writes the VPN configuration to file
func (pm *PfctlManager) WriteConfig(config *VPNConfig) error {
	if err := config.Validate(); err != nil {
		return fmt.Errorf("invalid VPN configuration: %w", err)
	}
	
	// Ensure directory exists
	dir := filepath.Dir(pm.vpnConfigPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}
	
	// Generate configuration
	pfConfig := pm.GenerateConfig(config)
	
	// Write to file
	if err := os.WriteFile(pm.vpnConfigPath, []byte(pfConfig), 0644); err != nil {
		return fmt.Errorf("failed to write pfctl configuration: %w", err)
	}
	
	return nil
}

// EnableRules enables the pfctl rules
func (pm *PfctlManager) EnableRules() error {
	// Load the VPN rules
	cmd := exec.Command("pfctl", "-f", pm.vpnConfigPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to load pfctl rules: %w, output: %s", err, string(output))
	}
	
	// Enable pfctl
	cmd = exec.Command("pfctl", "-e")
	output, err = cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to enable pfctl rules: %w, output: %s", err, string(output))
	}
	
	return nil
}

// DisableRules disables the pfctl rules
func (pm *PfctlManager) DisableRules() error {
	// Disable pfctl
	cmd := exec.Command("pfctl", "-d")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to disable pfctl: %w, output: %s", err, string(output))
	}
	
	return nil
}

// IsEnabled checks if pfctl is currently enabled
func (pm *PfctlManager) IsEnabled() (bool, error) {
	cmd := exec.Command("pfctl", "-s", "info")
	output, err := cmd.CombinedOutput()
	outputStr := string(output)
	
	if err != nil {
		// pfctl returns error when disabled or no permission, but we can still check output
		if strings.Contains(outputStr, "No ALTQ support in kernel") ||
		   strings.Contains(outputStr, "pfctl: pf not enabled") ||
		   strings.Contains(outputStr, "Permission denied") {
			return false, nil
		}
		// For other errors that don't give us useful information, return error
		if !strings.Contains(outputStr, "Status:") {
			return false, fmt.Errorf("failed to check pfctl status: %w", err)
		}
	}
	
	// Check if output indicates pfctl is enabled
	return strings.Contains(outputStr, "Status: Enabled"), nil
}

// GetStatus returns the current pfctl status
func (pm *PfctlManager) GetStatus() (*PfctlStatus, error) {
	enabled, err := pm.IsEnabled()
	if err != nil {
		return nil, err
	}
	
	status := &PfctlStatus{
		LastCheck: time.Now(),
		RuleCount: 0,
	}
	
	if enabled {
		status.State = "enabled"
		
		// Get rule count
		rules, err := pm.GetActiveRules()
		if err == nil {
			status.RuleCount = len(rules)
		}
	} else {
		status.State = "disabled"
	}
	
	return status, nil
}

// GetActiveRules returns the currently active pfctl rules
func (pm *PfctlManager) GetActiveRules() ([]PfctlRule, error) {
	cmd := exec.Command("pfctl", "-s", "rules")
	output, err := cmd.CombinedOutput()
	outputStr := string(output)
	
	if err != nil {
		// If pfctl is disabled or no permission, return empty rules instead of error
		if strings.Contains(outputStr, "pf not enabled") ||
		   strings.Contains(outputStr, "Permission denied") {
			return []PfctlRule{}, nil
		}
		return nil, fmt.Errorf("failed to get pfctl rules: %w", err)
	}
	
	var rules []PfctlRule
	lines := strings.Split(string(output), "\n")
	
	for i, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		
		rule := PfctlRule{
			ID:   i,
			Rule: line,
		}
		
		// Determine action
		if strings.HasPrefix(line, "pass") {
			rule.Action = "pass"
		} else if strings.HasPrefix(line, "block") {
			rule.Action = "block"
		} else if strings.HasPrefix(line, "nat") {
			rule.Action = "nat"
		} else {
			rule.Action = "other"
		}
		
		rules = append(rules, rule)
	}
	
	return rules, nil
}

// CreateBackup creates a backup of the current pfctl configuration
func (pm *PfctlManager) CreateBackup(backupPath string) error {
	// Ensure backup directory exists
	dir := filepath.Dir(backupPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}
	
	// Read current pfctl config
	var content []byte
	var err error
	
	if _, statErr := os.Stat(pm.configPath); statErr == nil {
		content, err = os.ReadFile(pm.configPath)
		if err != nil {
			return fmt.Errorf("failed to read pfctl configuration: %w", err)
		}
	} else {
		// If no config exists, create empty backup
		content = []byte("# Empty pfctl configuration backup\n")
	}
	
	// Write backup
	if err := os.WriteFile(backupPath, content, 0644); err != nil {
		return fmt.Errorf("failed to write backup: %w", err)
	}
	
	return nil
}

// RestoreFromBackup restores pfctl configuration from backup
func (pm *PfctlManager) RestoreFromBackup(backupPath string) error {
	// Read backup
	content, err := os.ReadFile(backupPath)
	if err != nil {
		return fmt.Errorf("failed to read backup file: %w", err)
	}
	
	// Write to pfctl config (requires root privileges)
	if err := os.WriteFile(pm.configPath, content, 0644); err != nil {
		return fmt.Errorf("failed to restore pfctl configuration: %w", err)
	}
	
	// Reload pfctl configuration
	cmd := exec.Command("pfctl", "-f", pm.configPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to reload pfctl configuration: %w, output: %s", err, string(output))
	}
	
	return nil
}

// Validate validates the VPN configuration
func (config *VPNConfig) Validate() error {
	if config.Interface == "" {
		return fmt.Errorf("interface name is required")
	}
	
	if config.ExternalInterface == "" {
		return fmt.Errorf("external interface name is required")
	}
	
	// Validate VPN network CIDR
	_, _, err := net.ParseCIDR(config.VPNNetwork)
	if err != nil {
		return fmt.Errorf("invalid VPN network CIDR: %w", err)
	}
	
	// Validate listen port
	if config.ListenPort != 0 && (config.ListenPort < 1 || config.ListenPort > 65535) {
		return fmt.Errorf("listen port must be between 1 and 65535")
	}
	
	// Validate allowed ports
	for _, port := range config.AllowedPorts {
		if port < 1 || port > 65535 {
			return fmt.Errorf("invalid allowed port %d: must be between 1 and 65535", port)
		}
	}
	
	return nil
}

// GetExternalInterface attempts to detect the default external interface
func GetExternalInterface() (string, error) {
	// Try to find the default route interface
	cmd := exec.Command("route", "get", "default")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get default route: %w", err)
	}
	
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, "interface:") {
			parts := strings.Split(line, ":")
			if len(parts) > 1 {
				return strings.TrimSpace(parts[1]), nil
			}
		}
	}
	
	// Fallback to common interface names
	commonInterfaces := []string{"en0", "en1", "eth0", "wlan0"}
	for _, iface := range commonInterfaces {
		if _, err := net.InterfaceByName(iface); err == nil {
			return iface, nil
		}
	}
	
	return "", fmt.Errorf("could not detect external interface")
}